import { supabase } from '@/integrations/supabase/client';
import { ServicioForm } from '@/types/planeacion';

export interface ImportResult {
  success: boolean;
  imported: number;
  failed: number;
  errors: string[];
  warnings: string[];
}

export interface ImportProgress {
  current: number;
  total: number;
  status: 'processing' | 'completed' | 'error';
  message?: string;
}

export const importServicios = async (
  data: any[],
  onProgress?: (progress: ImportProgress) => void
): Promise<ImportResult> => {
  const result: ImportResult = {
    success: false,
    imported: 0,
    failed: 0,
    errors: [],
    warnings: []
  };

  const total = data.length;
  let current = 0;

  try {
    // Process in batches to avoid overwhelming the database
    const batchSize = 50;
    const batches = [];
    
    for (let i = 0; i < data.length; i += batchSize) {
      batches.push(data.slice(i, i + batchSize));
    }

    for (const batch of batches) {
      try {
        // Process each item in the batch
        for (const item of batch) {
          current++;
          
          onProgress?.({
            current,
            total,
            status: 'processing',
            message: `Procesando registro ${current} de ${total}`
          });

          try {
            // Validate required fields
            if (!item.cliente_id || !item.fecha_programada || !item.origen_texto || !item.destino_texto) {
              result.failed++;
              result.errors.push(`Registro ${current}: Faltan campos requeridos`);
              continue;
            }

            // Set default values and prepare data for database
            const servicioData = {
              folio: item.folio || undefined,
              cliente: item.cliente || undefined,
              cliente_id: item.cliente_id,
              fecha_programada: item.fecha_programada,
              fecha_hora_recepcion_servicio: item.fecha_hora_recepcion_servicio || undefined,
              hora_programacion: item.hora_programacion || undefined,
              hora_ventana_inicio: item.hora_ventana_inicio || '09:00',
              hora_ventana_fin: item.hora_ventana_fin || '17:00',
              origen_texto: item.origen_texto,
              origen_lat: item.origen_lat,
              origen_lng: item.origen_lng,
              destino_texto: item.destino_texto,
              destino_lat: item.destino_lat,
              destino_lng: item.destino_lng,
              tipo_servicio: item.tipo_servicio || 'traslado',
              custodio_asignado_id: item.custodio_asignado_id || undefined,
              requiere_gadgets: item.requiere_gadgets || false,
              notas_especiales: item.notas_especiales || '',
              prioridad: item.prioridad || 1,
              valor_estimado: item.valor_estimado || 0,
              estado: 'nuevo' as const
            };

            // Insert into database (folio will be auto-generated by trigger)
            const { data: insertedData, error } = await supabase
              .from('pc_servicios')
              .insert(servicioData as any)
              .select()
              .single();

            if (error) {
              result.failed++;
              result.errors.push(`Registro ${current}: Error de base de datos - ${error.message}`);
            } else {
              result.imported++;
            }

          } catch (itemError) {
            result.failed++;
            result.errors.push(`Registro ${current}: ${itemError instanceof Error ? itemError.message : 'Error desconocido'}`);
          }
        }

        // Small delay between batches to prevent overwhelming the server
        if (batches.indexOf(batch) < batches.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }

      } catch (batchError) {
        result.failed += batch.length;
        result.errors.push(`Error en lote: ${batchError instanceof Error ? batchError.message : 'Error desconocido'}`);
      }
    }

    result.success = result.failed === 0;
    
    onProgress?.({
      current: total,
      total,
      status: result.success ? 'completed' : 'error',
      message: result.success 
        ? `Importación completada: ${result.imported} registros importados`
        : `Importación completada con errores: ${result.imported} importados, ${result.failed} fallidos`
    });

  } catch (error) {
    result.errors.push(`Error general: ${error instanceof Error ? error.message : 'Error desconocido'}`);
    
    onProgress?.({
      current,
      total,
      status: 'error',
      message: 'Error durante la importación'
    });
  }

  return result;
};

export const validateClienteExists = async (clienteId: string): Promise<boolean> => {
  try {
    const { data, error } = await supabase
      .from('pc_clientes')
      .select('id')
      .eq('id', clienteId)
      .single();

    return !error && !!data;
  } catch {
    return false;
  }
};

export const getClientesList = async (): Promise<Array<{ id: string; nombre: string }>> => {
  try {
    const { data, error } = await supabase
      .from('pc_clientes')
      .select('id, nombre')
      .order('nombre');

    if (error) throw error;
    return data || [];
  } catch {
    return [];
  }
};